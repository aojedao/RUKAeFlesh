import serial
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from collections import deque
import re
import datetime
import sys

# --- Configuration ---
SERIAL_PORT = '/dev/ttyACM0'    # CHANGE THIS to your Arduino's serial port (e.g., 'COM3' or '/dev/ttyACM0')
BAUD_RATE = 115200      # CHANGE THIS to your Arduino's baud rate
MAX_SAMPLES = 50       # Maximum number of data points to display on the graph
REFRESH_RATE_MS = 0.1     # Animation refresh rate in milliseconds (lower = faster updates)
MAX_BOARDS = 21         # Maximum number of boards to support (determines subplot layout)
LOG_FILENAME = f"arduino_readings_{datetime.datetime.now():%Y%m%d_%H%M%S}.txt"

# Data structure to hold the history of readings for each signal
# Key format: "BoardXSensorYAxis" e.g., "B1S0X"
DATA_STREAMS = {}

# Define all unique data streams based on your description
# Boards 1-3 (5 sensors each): BxSyAxis (x=1..3, y=0..4, Axis=X,Y,Z) -> 3 * 5 * 3 = 45 streams
# Boards 4-9 (1 sensor each): BxS0Axis (x=4..9, y=0, Axis=X,Y,Z) -> 6 * 1 * 3 = 18 streams
# TOTAL: 63 unique data streams.

# Function to generate the stream keys
def generate_stream_keys():
    keys = []
    # Generate keys for all possible board/sensor combinations
    for board in range(0, MAX_BOARDS):
        # Board types: 5X boards have sensors 0-4, 1X boards have sensor 0
        # For simplicity, generate keys for all possible sensors (0-4) for each board
        for sensor in range(0, 5):  # Max 5 sensors per board
            for axis in ['X', 'Y', 'Z']:
                keys.append(f"B{board}S{sensor}{axis}")
    return keys

# Initialize data structures (Sample number is the common x-axis for all)
ALL_KEYS = generate_stream_keys()
SAMPLE_COUNTER = deque(maxlen=MAX_SAMPLES)

# Initialize with sample 0
SAMPLE_COUNTER.append(0)
current_sample = 0

for key in ALL_KEYS:
    DATA_STREAMS[key] = deque(maxlen=MAX_SAMPLES)
    # Initialize with 0 to prevent Matplotlib errors on first draw
    DATA_STREAMS[key].append(0.0) 

# Regular expression to parse the input: "Board0Sensor0X:-7.20" (Arduino output format)
# Group 1: Board Number (0)
# Group 2: Sensor Number (0)
# Group 3: Axis (X)
# Group 4: Value (-7.20)
PARSE_PATTERN = re.compile(r"Board(\d+)Sensor(\d+)([XYZ]):\s*([-+]?\d*\.?\d+)")

# --- Serial and Logging Setup ---

try:
    ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=0.1)
    ser.flushInput()
    print(f"Successfully connected to {SERIAL_PORT} at {BAUD_RATE} baud.")
except serial.SerialException as e:
    print(f"Error opening serial port {SERIAL_PORT}: {e}")
    sys.exit(1)

# Open log file for appending, write header
try:
    log_file = open(LOG_FILENAME, 'a')
    # Write a header for the log file
    log_file.write("Timestamp," + ",".join(ALL_KEYS) + "\n")
    print(f"Logging data to {LOG_FILENAME}")
except IOError as e:
    print(f"Error opening log file: {e}")
    ser.close()
    sys.exit(1)

# --- Data Acquisition and Parsing Function ---

def get_serial_data():
    """Reads one line from serial, parses it, updates data structure, and logs."""
    try:
        if ser.in_waiting > 0:
            # Read a line, decode it from bytes, and strip whitespace/newline
            line = ser.readline().decode('utf-8').strip()
            
            if not line:
                return False # Nothing to process
            
            # Debug: print the line we're trying to parse (first few characters only)
            # print(f"Parsing line: '{line[:100]}...'")  # Comment out to reduce spam
            
            # Find all matches in the line (multiple sensor readings per line)
            matches = PARSE_PATTERN.findall(line)
            
            if matches:
                global current_sample
                data_updated = False
                
                # Keep track of which keys we've already processed in this line
                # to avoid duplicate data points
                processed_keys = set()
                
                # Dictionary to collect all sensor values for this timestamp
                current_values = {}
                
                for match in matches:
                    board_num = match[0]
                    sensor_num = match[1]  # Now we capture the actual sensor number
                    axis = match[2]
                    value_str = match[3]
                    
                    try:
                        value = float(value_str)
                    except ValueError:
                        print(f"Skipping invalid value: {value_str}")
                        continue
                    
                    # Use the actual sensor number from the Arduino output
                    key = f"B{board_num}S{sensor_num}{axis}"
                    
                    # Skip if we've already processed this key in this line
                    if key in processed_keys:
                        continue
                        
                    processed_keys.add(key)
                    
                    if key in DATA_STREAMS:
                        # Add the new value
                        DATA_STREAMS[key].append(value)
                        
                        # Store value for CSV logging
                        current_values[key] = value
                        
                        data_updated = True
                    else:
                        print(f"Unknown key: {key}")
                
                if data_updated:
                    # Write CSV row with timestamp and all sensor values
                    timestamp = datetime.datetime.now().strftime("%H:%M:%S.%f")
                    row_values = [timestamp]
                    
                    # Add values for each key in the same order as header
                    for key in ALL_KEYS:
                        if key in current_values:
                            row_values.append(str(current_values[key]))
                        else:
                            row_values.append("")  # Empty string for missing values
                    
                    log_file.write(",".join(row_values) + "\n")
                    
                    # Update sample counter once per line
                    current_sample += 1
                    SAMPLE_COUNTER.append(current_sample)
                    log_file.flush()
                    return True
                    
            else:
                # Only print no matches for non-empty, non-debug lines
                if line and not line.startswith("---") and not line.startswith("Board Configuration"):
                    print(f"No matches found in line: {line[:50]}...")
                    # Debug: show what pattern we're looking for
                    print(f"Pattern expects: Board<number>Sensor<number><X/Y/Z>:<value>")

    except serial.SerialException as e:
        print(f"Serial error: {e}")
    except KeyboardInterrupt:
        print("\nStopping...")
        return None # Indicate to stop animation
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        
    return False

# --- Plotting Setup ---

# Calculate optimal subplot layout based on number of sensors (boards)
import math
active_sensors = MAX_BOARDS  # Each board represents one sensor (S0, S1, S2, etc.)
cols = int(math.ceil(math.sqrt(active_sensors)))
rows = int(math.ceil(active_sensors / cols))

# Create dynamic subplot configuration
fig, axes = plt.subplots(nrows=rows, ncols=cols, figsize=(4*cols, 3*rows))
fig.suptitle('Arduino Sensor Readings Live Plot', fontsize=16)

# Adjust spacing to make room for legends outside plots
plt.subplots_adjust(hspace=0.5, wspace=0.4, right=0.85)

# Flatten the array of axes for easier indexing (handle single plot case)
if active_sensors == 1:
    axes = [axes]
elif rows == 1 or cols == 1:
    axes = axes.flatten() if hasattr(axes, 'flatten') else axes
else:
    axes = axes.flatten()

# Prepare lines for each graph
lines = {}
plot_index = 0

# Organize plots by sensor number (each plot shows one sensor: S0, S1, S2, etc.)
for sensor_num in range(0, active_sensors):
    if plot_index < len(axes):
        ax = axes[plot_index]
        ax.set_title(f'S{sensor_num}', fontsize=10)
        ax.tick_params(axis='x', rotation=45)
        ax.grid(True)
        
        # List of keys for this sensor (from board sensor_num, sensor 0)
        sensor_keys = []
        
        # Each "sensor" corresponds to a board number (S0 = Board 0, S1 = Board 1, etc.)
        # Arduino sends Board{X}Sensor{Y} where Y is always 0
        for axis in ['X', 'Y', 'Z']:
            key = f"B{sensor_num}S0{axis}"
            if key in DATA_STREAMS:  # Only add if key exists in data streams
                sensor_keys.append(key)
        
        # Plot the initial line for each axis of this sensor
        for key in sensor_keys:
            # Initial plot: line, = ax.plot(X_data, Y_data, label)
            # Ensure both sample counter and data have the same length
            sample_list = list(SAMPLE_COUNTER)
            data_list = list(DATA_STREAMS.get(key, []))
            min_len = min(len(sample_list), len(data_list))
            
            # Create label in format S{sensor_num}{axis} (e.g., "S0X", "S0Y", "S0Z")
            axis_char = key[-1]  # Last character is the axis (X, Y, or Z)
            axis_label = f"S{sensor_num}{axis_char}"
            
            if min_len > 0:
                line, = ax.plot(sample_list[-min_len:], data_list[-min_len:], label=axis_label)
            else:
                line, = ax.plot([], [], label=axis_label)
            lines[key] = line
            
        # Move legend outside the plot area to the right (only if there are lines to show)
        if sensor_keys:
            ax.legend(bbox_to_anchor=(1.1, 1), loc='upper left', fontsize='xx-small')
        plot_index += 1

# Hide any unused subplots
for i in range(plot_index, len(axes)):
    axes[i].set_visible(False)


# --- Animation Function ---

def animate(i):
    """Function called by FuncAnimation to update the plot."""
    result = get_serial_data()
    if result is None:
        # Stop the animation if get_serial_data returns None (e.g., on KeyboardInterrupt)
        anim.event_source.stop()
        ser.close()
        log_file.close()
        print("\nSerial connection and logging closed.")
        plt.close(fig)
        return []
    
    # If new data was processed, update all plots
    if result:
        sample_numbers = list(SAMPLE_COUNTER)
        
        # Update each line object
        for key, line in lines.items():
            data_values = list(DATA_STREAMS.get(key, [0.0]))
            # Ensure sample numbers and data arrays are the same length
            min_len = min(len(sample_numbers), len(data_values))
            if min_len > 0:
                line.set_data(sample_numbers[-min_len:], data_values[-min_len:])

        # Rescale and redraw all visible sensor plots
        for i, ax in enumerate(axes):
            if i < active_sensors and sample_numbers:
                ax.relim()
                ax.autoscale_view()
        
        # Force redraw
        fig.canvas.draw_idle()
    
    return list(lines.values()) # Return all updated artists

# --- Main Execution ---

try:
    # Start the animation loop
    # Use configurable refresh rate
    anim = animation.FuncAnimation(fig, animate, interval=REFRESH_RATE_MS, blit=False)
    plt.show()

except KeyboardInterrupt:
    print("\nProgram terminated by user.")
finally:
    # Ensure serial and log file are closed if the program exits unexpectedly
    if 'ser' in locals() and ser.is_open:
        ser.close()
    if 'log_file' in locals() and not log_file.closed:
        log_file.close()